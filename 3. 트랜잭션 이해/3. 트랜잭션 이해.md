## 트랜잭션 이해

### 트랜잭션 - 개념 이해

- 데이터베이스에서 트랜잭션은 하나의 거래를 안전하게 처리하도록 보장해주는 것을 뜻함

- 모든 작업이 성공해서 데이터베이스에 정상 반영하는 것을 커밋(Commit)이라 하고, 작업 중 하나라도 실패해서 거래 이전으로 되돌리는 것을 롤백이라 함

- 트랜잭션 ACID

1. 원자성 (Atomicity): 트랜잭션 내에서 실행한 작업들은 마치 하나의 작업인 것처럼 모두 성공하거나 모두 실패해야 함

2. 일관성 (Consistency): 모든 트랜잭션은 일관성 있는 데이터베이스 상태를 유지해야 함

3. 격리성 (Isolation): 동시에 실행되는 트랜잭션들이 서로에게 영향을 미치지 않도록 격리함

   cf) 격리성은 동시성과 관련된 성능 이슈로 인해 트랜잭션 격리 수준을 선택할 수 있음

4. 지속성 (Durability): 트랜잭션을 성공적으로 끝내면 그 결과가 항상 기록되어야 함

---

### 데이터베이스 연결 구조와 DB 세션

- 사용자는 WAS나 DB 접근 툴 같은 클라이언트를 사용해서 DB 서버에 접근할 수 있음

- 클라이언트는 DB 서버에 연결을 요청하고 커넥션을 맺게 됨. 이때 DB 서버는 내부에 세션이라는 것을 만듦. 그리고 앞으로 해당 커넥션을 통한 모든 요청은 이 세션을 통해서 실행하게 됨

- 즉, 개발자가 클라이언트를 통해 SQL을 전달하면 현재 커넥션에 연결된 세션이 SQL을 실행함

- 세션은 트랜잭션을 시작하고, 커밋 또는 롤백을 통해 트랜잭션을 종료함. 그리고 이후에 새로운 트랜잭션을 다시 시작할 수 있음

- 사용자가 커넥션을 닫거나, 또는 DBA가 세션을 강제로 종료하면 세션은 종료됨

- 커넥션 풀이 10개의 커넥션을 생성하면, 세션도 10개 만들어짐

---

### 트랜잭션 - DB 예제1 - 개념 이해

- 트랜잭션 사용법

  → 데이터 변경 쿼리를 실행하고 DB에 그 결과를 반영하려면 커밋 명령어인 commit을 호출하고, 결과를 반영하고 싶지 않으면 롤백 명령어인 rollback을 호출하면 됨

  → 커밋을 호출하기 전까지는 임시로 데이터를 저장하는 것임. 따라서 해당 트랜잭션을 시작한 세션(사용자)에게만 변경 데이터가 보이고 다른 세션(사용자)에게는 변경 데이터가 보이지 않음

  → 등록, 수정, 삭제 모두 같은 원리로 동작함

- 강의자료 예제 참고

---

### 트랜잭션 - DB 예제2 - 자동 커밋, 수동 커밋

- 자동 커밋

  → 자동 커밋으로 설정하면 각각의 쿼리 실행 직후에 자동으로 커밋을 호출함

  → 따라서 커밋이나 롤백을 직접 호출하지 않아도 되는 편리함이 있음

  → 하지만 쿼리를 하나하나 실행할 때마다 자동으로 커밋이 되어버리기 때문에 우리가 원하는 트랜잭션 기능을 제대로 사용할 수 없음

  ```sql
  set autocommit true; //자동 커밋 모드 설정
  insert into member(member_id, money) values ('data1',10000); //자동 커밋
  insert into member(member_id, money) values ('data2',10000); //자동 커밋
  ```

- 수동 커밋

  → commit, rollback을 직접 호출하면서 트랜잭션 기능을 제대로 수행하려면 자동 커밋을 끄고 수동 커밋을 사용해야 함

  → 보통 자동 커밋 모드가 기본으로 설정된 경우가 많기 때문에, 수동 커밋 모드로 설정하는 것을 트랜잭션을 시작한다고 표현함

  → 수동 커밋 설정을 하면 이후에 꼭 commit, rollback을 호출해야 함

  ```sql
  set autocommit false; //수동 커밋 모드 설정
  insert into member(member_id, money) values ('data3',10000);
  insert into member(member_id, money) values ('data4',10000);
  commit; //수동 커밋
  ```

  cf) 수동 커밋 모드나 자동 커밋 모드는 한번 설정하면 해당 세션에서는 계속 유지됨. 중간에 변경하는 것은 가능함

---

### 트랜잭션 - DB 예제3 - 트랜잭션 실습

- 강의자료 예제 참고

---

### 트랜잭션 - DB 예제4 - 계좌이체

- 강의자료 예제 참고

---

### DB 락 - 개념 이해

- 세션이 트랜잭션을 시작하고 데이터를 수정하는 동안에는 커밋이나 롤백 전까지 다른 세션에서 해당 데이터를 수정할 수 없게 막아야 함

- 락 예시

1. 세션1 트랜잭션 시작

2. 세션1은 memberA의 money를 500으로 변경을 시도함. 이때 해당 로우의 락을 먼저 획득해야 함. 락이 남아 있으므로 세션 1은 락을 획득함 (세션1이 세션2보다 조금 떠 빨리 요청함)

3. 세션1은 락을 획득했으므로 해당 로우에 update sql을 수행함

4. 세션2 트랜잭션 시작

5. 세션2도 memberA의 money 데이터를 변경하려고 시도함. 이때 해당 로우의 락을 먼저 획득해야 함. 락이 없으므로 락이 돌아올 때까지 대기함

   cf) 참고로 세션2가 락을 무한정 대기하는 것은 아님. 락 대기 시간을 넘어가면 락 타임아웃 오류가 발생함. 락 대기 시간은 설정할 수 있음

6. 세션1은 커밋을 수행함. 커밋으로 트랜잭션이 종료되었으므로 락도 반납함

7. 락을 획득하기 위해 대기하던 세션2가 락을 획득하고 update sql을 수행함

8. 세션2는 커밋을 수행하고 트랜잭션이 종료되었으므로 락을 반납함

---

### DB 락 - 변경

- 강의자료 예제 참고

---

### DB 락 - 조회

- 일반적인 조회는 락을 사용하지 않음

- 데이터를 조회할 때도 락을 획득하고 싶을 때도 있음. 이럴 때는 select for update 구문을 사용하면 됨

- 트랜잭션 종료 시점까지 해당 데이터를 다른 곳에서 변경하지 못하도록 강제로 막아야 할 때 사용함

- 트랜잭션과 락은 데이터베이스마다 실제 동작하는 방식이 조금씩 다르기 때문에, 해당 데이터베이스 매뉴얼을 확인해보고 의도한대로 동작하는지 테스트한 이후에 사용해야함

- 강의자료 예제 참고

---

### 트랜잭션 - 적용1

- github 실습 코드 참고

---

### 트랜잭션 - 적용2

- 비즈니스 로직과 트랜잭션

  → 트랜잭션은 비즈니스 로직이 있는 서비스 계층에서 시작해야 함. 비즈니스 로직이 잘못되면 해당 비즈니스 로직으로 인해 문제가 되는 부분을 함께 롤백해야 하기 때문

  → But, 트랜잭션을 시작하려면 커넥션이 필요함. 결국 서비스 계층에서 커넥션을 만들고, 트랜잭션 커밋 이후에 커넥션을 종료해야 함

  → 애플리케이션에서 DB 트랜잭션을 사용하려면 트랜잭션을 사용하는 동안 같은 커넥션을 유지해야 함. 그래야 같은 세션을 사용할 수 있음

- github 실습 코드 참고

---

### 정리 및 회고

- 보통 애플리케이션에서 트랜잭션은 비즈니스 로직이 있는 서비스 계층에서 시작함

- 트랜잭션 격리 수준에 대해서는 깊은 공부가 필요할 것 같음
